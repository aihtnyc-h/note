에러 노트

```sql
<update id="updateAccumlatedCharges" parameterType="mdt.restapi.com.mobile.model.PaymentModel">  
    UPDATE tb_accumulated_charges ch  
    SET ch.accumulated_amount = #{remainPrice} + ch.accumulated_amount  
    WHERE token_id = #{tokenId};  
</update>
```

ERROR 24-10-29 08:29:14[http-nio-8089-exec-2] [[dispatcherServlet]:175] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.apache.ibatis.binding.BindingException: Mapper method 'mdt.restapi.com.mobile.mapper.PaymentMapper.updateAccumlatedCharges' has an unsupported return type: class mdt.restapi.com.mobile.model.PaymentModel] with root cause

메소드의 반환 타입이 `PaymentModel`로 설정되어 있지만, MyBatis에서 지원하지 않는 타입이라는 것

일반적으로 업데이트 쿼리는 반환값이 필요 없거나, 업데이트된 행의 수를 반환하는 경우가 많다. `PaymentModel`이 아닌 `int` 타입으로 변경

`int updateAccumlatedCharges(PaymentModel paymentModel);`


--------

```sql
<select id="selectEventAccumulation" resultType="String">  
    SELECT  
           ac.token_id AS token_id  
         , ac.accumulated_amount AS accumulatedAmount  
         , ac.first_reward AS firstReward  
         , ac.second_reward AS secondReward  
    FROM  
        tb_accumulated_charges ac  
    WHERE token_id = #{token_id}  
</select>
```

```java
List<PaymentModel> con1 = paymentMapper.selectEventAccumulation(paymentModel.getToken_id()); System.out.println("con1 : " + con1);
con1 : test@naver.com
```

resultType이 String 만 되어 있기 때문에 String 값만 확인이 가능

```sql
<select id="selectEventAccumulation" resultType="mdt.restapi.com.mobile.model.PaymentModel">  
    SELECT  
           ac.token_id AS token_id  
         , ac.accumulated_amount AS accumulatedAmount  
         , ac.first_reward AS firstReward  
         , ac.second_reward AS secondReward  
    FROM  
        tb_accumulated_charges ac  
    WHERE token_id = #{token_id}  
</select>
```

resultType 값을 잊지 말자!

------

```sql
SELECT SUM(tpcr.confirm_price) AS accumulatedAmount FROM
tb_payment_cancel_repay tpcr
WHERE tpcr.chargebox_id = 'MDTQ0012'
AND tpcr.timestamp >= CURDATE() - INTERVAL 1 DAY  -- 전일 00:00:00
AND tpcr.timestamp < CURDATE();                    -- 오늘 00:00:00
```

```
AND tpcr.timestamp < CURDATE();                    -- 오늘 00:00:00

Tag name expected
= expected

```

AND tpcr.timestamp < CURDATE(); 여기에 에러가 발생함

### XML 파서 문제

XML 파서가 `<`, `>`와 같은 기호를 해석하면서 구문 오류를 발생시킬 수 있습니다. XML에서 SQL 구문을 작성할 때는 종종 CDATA 섹션을 사용하여 파싱 문제를 방지합니다.

```sql
<![CDATA[
AND tpcr.timestamp < CURDATE()
]]>
```

-----



```sql
SELECT 
       SUM(tpcr.confirm_price) AS accumulatedAmount 
FROM tb_payment_cancel_repay tpcr 
WHERE 
    tpcr.chargebox_id = 'MDTQ0012' 
AND tpcr.token_id = 'test@naver.com' 
AND tpcr.timestamp >= CURDATE() - INTERVAL 1 DAY 
AND tpcr.timestamp < CURDATE() GROUP BY tpcr.timestamp;
```

이렇게 계산하면 쉽지만, 추후 알림톡을 발송하기 위해 시간도 필요!!

```sql
SELECT 
       SUM(tpcr.confirm_price) AS accumulatedAmount 
     , tpcr.timestamp 
FROM tb_payment_cancel_repay tpcr 
WHERE 
    tpcr.chargebox_id = 'MDTQ0012' 
AND tpcr.token_id = 'test@naver.com' 
AND tpcr.timestamp >= CURDATE() - INTERVAL 1 DAY 
AND tpcr.timestamp < CURDATE() GROUP BY tpcr.timestamp;
GROUP BY tpcr.timestamp;
```

이렇게 조회하면 충전이 여러 개 일 때 값이 SUM을 사용한 보람이 없다...

```sql
<![CDATA[  
    /* api-reti.xml|selectEventAccumulation|이벤트 1. 충전금액 확인 pha */  
    SELECT  
           SUM(tpcr.confirm_price) AS accumulatedAmount  
         , MAX(tpcr.timestamp) AS timestamp  
    FROM  
        tb_payment_cancel_repay tpcr  
    WHERE  
        tpcr.chargebox_id = 'MDTQ0012'  
      AND tpcr.token_id = 'test@naver.com'  
      AND tpcr.timestamp >= CURDATE() - INTERVAL 1 DAY  
      AND tpcr.timestamp < CURDATE()  
    ]]>
```

전일 기준으로 조회하는 쿼리이기 때문에 timestamp를 MAX 값을 조회한다!

-----

